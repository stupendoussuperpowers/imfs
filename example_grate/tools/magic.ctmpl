/*
This is an auto-generated file. Do not modify.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <register_handler.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <lind_syscall_num.h>
#include "magic.h"

extern int grate_syscalls[];
extern size_t grate_syscalls_len;

lvar_t l_alloc(int size) {
	char *val = malloc(size);
	return (lvar_t) {
		.value = (uint64_t)val,
		.cage = thiscage,
	};
}

void l_free(lvar_t ptr) {
	free((char *)ptr.value);
}

void register_handlers(int cageid, int grateid) {
	int ret;
	for(int i=0; i < grate_syscalls_len; i++) {
		ret = register_handler(cageid, grate_syscalls[i], 0, grateid);
		printf("Registered: %d\n", grate_syscalls[i]);
	}
}

// Main function will always be same in all grates
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <cage_file> <grate_file> <cage_file> [...]\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    int grateid = getpid();
    
    for (int i = 1; i < (argc < 3 ? argc : 3); i++) {
        pid_t pid = fork();
        if (pid < 0) {
            perror("fork failed");
            exit(EXIT_FAILURE);
        } else if (pid == 0) {
            // will always be cage.
            if (i % 2 != 0) {
                int cageid = getpid();
                
		register_handlers(cageid, grateid);	
	    }

	    printf("Execing %s\n", argv[i]);
            if (execv(argv[i], &argv[i]) == -1) {
                perror("execv failed");
                exit(EXIT_FAILURE);
            }
	} else {
		grate_init();
	}
    }

    int status;
    while (wait(&status) > 0) {
        printf("[Grate | geteuid] terminated, status: %d\n", status);
    }

    return 0;
}

